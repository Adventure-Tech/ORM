<?php

namespace AdventureTech\ORM\Persistence;

use AdventureTech\ORM\EntityAccessorService;
use AdventureTech\ORM\EntityReflection;
use AdventureTech\ORM\Exceptions\InconsistentEntitiesException;
use AdventureTech\ORM\Exceptions\InvalidRelationException;
use AdventureTech\ORM\Exceptions\MissingIdValueException;
use AdventureTech\ORM\Exceptions\MissingOwningRelationException;
use AdventureTech\ORM\Exceptions\MissingValueForColumnException;
use AdventureTech\ORM\Exceptions\PersistenceException;
use AdventureTech\ORM\Mapping\Linkers\OwningLinker;
use AdventureTech\ORM\Mapping\Linkers\PivotLinker;
use Carbon\CarbonInterface;
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use stdClass;

/**
 * @template T of object
 */
abstract class PersistenceManager
{
    private EntityReflection $entityReflection;
    private bool $hasAutogeneratedId;
    private array $insertEntities = [];
    private array $insertValues = [];
    private array $updateEntities = [];
    private array $updateValues = [];
    private array $deleteEntities = [];
    private array $deleteIds = [];
    private array $errors = [];

    /**
     * @return class-string<T>
     */
    abstract protected function getEntityClassName(): string;

    protected function __construct()
    {
        $this->entityReflection = EntityReflection::new($this->getEntityClassName());
        $this->hasAutogeneratedId = $this->entityReflection->hasAutogeneratedId();
    }

    public static function new(): static
    {
        return new static();
    }

    public function registerInsert(object $entity): static
    {
        $this->checkType($entity);
        if ($this->hasAutogeneratedId && EntityAccessorService::issetId($entity)) {
            throw new PersistenceException('Must not set autogenerated ID column when inserting entities.');
        }
        if (!$this->hasAutogeneratedId && !EntityAccessorService::issetId($entity)) {
            throw new PersistenceException('Must set non-autogenerated ID column when inserting entities.');
        }
        // TODO: is this desired behaviour at this point?
        foreach ($this->entityReflection->getManagedColumns() as $property => $managedColumn) {
            EntityAccessorService::set($entity, $property, $managedColumn->getInsertValue());
        }
        foreach ($this->entityReflection->getSoftDeletes() as $property => $softDelete) {
            EntityAccessorService::set($entity, $property, null);
        }
        $this->insertEntities[] = $entity;
        $this->insertValues[] = $this->serializeEntity($entity, false);

        return $this;
    }

    public function registerUpdate(object $entity): static
    {
        $this->checkType($entity);
        if (!EntityAccessorService::issetId($entity)) {
            throw new PersistenceException('Must set ID column when updating entities.');
        }
        $unsetManagedColumns = [];
        foreach ($this->entityReflection->getManagedColumns() as $property => $managedColumn) {
            $updateValue = $managedColumn->getUpdateValue();
            if (!is_null($updateValue)) {
                EntityAccessorService::set($entity, $property, $updateValue);
            } else {
                $unsetManagedColumns[$property] = $property;
            }
        }
        foreach ($this->entityReflection->getSoftDeletes() as $property => $softDelete) {
            EntityAccessorService::set($entity, $property, null);
        }
        $this->updateEntities[] = $entity;
        $this->updateValues[] = $this->serializeEntity($entity, true);

        // TODO: ensure cannot update soft-deleted entities
        // TODO: skip managed columns whose ->getUpdateValue() returns null and leave them unchanged on DB
        // TODO: check we updated everything we wanted to: self::checkNumberOfRowsAffected($updatedRowCount, 'Could not update entity');

        return $this;
    }

    public function registerDelete(object $entity, CarbonInterface $deletedAt = null, bool $force = false): static
    {
        $this->checkType($entity);
        if (!EntityAccessorService::issetId($entity)) {
            throw new PersistenceException('Must set ID column when deleting entities.');
        }

        $isSoftDelete = false;
        foreach ($this->entityReflection->getSoftDeletes() as $property => $softDelete) {
            EntityAccessorService::set($entity, $property, $deletedAt ?? $softDelete->getDatetime());
            $isSoftDelete = true;
        }

        if ($isSoftDelete && !$force) {
            $this->updateEntities[] = $entity;
            $this->updateValues[] = $this->serializeEntity($entity, true);
        } else {
            $this->deleteEntities[] = $entity;
            $this->deleteIds[] = EntityAccessorService::getId($entity);
        }
        return $this;
    }

    public function registerRestore(object $entity): static
    {
        $this->checkType($entity);
        if (!EntityAccessorService::issetId($entity)) {
            throw new PersistenceException('Must set ID column when restoring entities.');
        }
        foreach ($this->entityReflection->getSoftDeletes() as $property => $softDelete) {
            EntityAccessorService::set($entity, $property, null);
        }
        $this->updateEntities[] = $entity;
        $this->updateValues[] = $this->serializeEntity($entity, true);
        return $this;
    }

    public function persist(): void
    {
        $this->persistInserts();
        $this->persistUpdates();
        $this->persistDeletes();

        if (count($this->errors) > 0) {
            throw new PersistenceException(implode("\n", $this->errors));
        }
    }


    /**
     * @param  T  $entity
     *
     * @return void
     */
    public static function insert(object $entity): void
    {
        static::new()->registerInsert($entity)->persist();
    }

    /**
     * @param  T  $entity
     *
     * @return void
     */
    public static function update(object $entity): void
    {
        static::new()->registerUpdate($entity)->persist();
    }

    /**
     * @param  T  $entity
     *
     * @return void
     */
    public static function delete(object $entity): void
    {
        static::new()->registerDelete($entity)->persist();
    }

    /**
     * @param  T  $entity
     *
     * @return void
     */
    public static function forceDelete(object $entity): void
    {
        static::new()->registerDelete($entity, force: true)->persist();
    }

    /**
     * @param  T  $entity
     *
     * @return void
     */
    public static function restore(object $entity): void
    {
        static::new()->registerRestore($entity)->persist();
    }

    /**
     * @param  T  $entity
     * @param  Collection<int|string,object>|array<int|string,object>  $linkedEntities
     * @param  string  $relation
     * @return int
     */
    public static function attach(object $entity, Collection|array $linkedEntities, string $relation): int
    {
        $entityReflection = self::getEntityReflection();

        $linker = $entityReflection->getLinkers()->get($relation);

        $linkedEntities = Collection::wrap($linkedEntities);

        if (!($linker instanceof PivotLinker)) {
            throw new InvalidRelationException('Can only attach pure many-to-many relations');
        }

        self::checkIdIsSet($entity, 'Must set ID column on base entity when attaching/detaching');

        $data = self::getPivotData($entityReflection, $entity, $linker, $linkedEntities);

        EntityAccessorService::set($entity, $relation, $linkedEntities);

        return DB::table($linker->getPivotTable())->insertOrIgnore($data);
    }

    /**
     * @param  T  $entity
     * @param  Collection<int|string,object>|array<int|string,object>  $linkedEntities
     * @param  string  $relation
     * @return int
     */
    public static function detach(object $entity, Collection|array $linkedEntities, string $relation): int
    {
        $entityReflection = self::getEntityReflection();

        $linker = $entityReflection->getLinkers()->get($relation);

        $linkedEntities = Collection::wrap($linkedEntities);

        if (!($linker instanceof PivotLinker)) {
            throw new InvalidRelationException('Can only detach pure many-to-many relations');
        }

        self::checkIdIsSet($entity, 'Must set ID column on base entity when detaching');

        $data = self::getPivotData($entityReflection, $entity, $linker, $linkedEntities);

        if (EntityAccessorService::isset($entity, $relation)) {
            $linkedEntityIds = $linkedEntities->mapWithKeys(fn ($entity) => [
                EntityAccessorService::getId($entity) => EntityAccessorService::getId($entity)
            ]);
            /** @var Collection<int|string,object> $currentRelationValue */
            $currentRelationValue = EntityAccessorService::get($entity, $relation);
            $newRelationValue = $currentRelationValue->filter(fn($entity) => !EntityAccessorService::issetId($entity)
                || $linkedEntityIds->doesntContain(EntityAccessorService::getId($entity)));
            EntityAccessorService::set($entity, $relation, $newRelationValue);
        }

        $int = 0;
        foreach ($data as $item) {
            $int += DB::table($linker->getPivotTable())->where($item)->delete();
        }

        return $int;
    }

    /**
     * @param  object  $entity
     * @return array<string,mixed>
     */
    private function resolveOwningRelations(object $entity): array
    {
        $data = [];
        foreach ($this->entityReflection->getLinkers() as $property => $linker) {
            if ($linker instanceof OwningLinker) {
                if (!$this->entityReflection->allowsNull($property) && !EntityAccessorService::isset($entity, $property)) {
                    throw new MissingOwningRelationException('Must set all non-nullable owning relations');
                }
                if (EntityAccessorService::isset($entity, $property)) {
                    /** @var object $linkedEntity */
                    $linkedEntity = EntityAccessorService::get($entity, $property);
                    self::checkIdIsSet($linkedEntity, 'Owned linked entity must have valid ID set');
                    $data[$linker->getForeignKey()] = EntityAccessorService::getId($linkedEntity);
                } else {
                    $data[$linker->getForeignKey()] = null;
                }
            }
        }
        return $data;
    }

    /**
     * @param  T  $entity
     *
     * @return EntityReflection<T>
     */
    private static function getEntityReflection(): EntityReflection
    {
        return static::new()->entityReflection;
    }

    /**
     * @param  object  $entity
     * @param  string  $message
     * @return void
     */
    private static function checkIdIsSet(object $entity, string $message): void
    {
        if (!EntityAccessorService::issetId($entity)) {
            throw new MissingIdValueException($message);
        }
    }

    /**
     * @template D of object
     * @param  EntityReflection<D>  $entityReflection
     * @param  D  $entity
     * @param  PivotLinker<D>  $linker
     * @param  Collection<int|string,object>  $linkedEntities
     * @return array<int|string,array<string,mixed>>
     */
    private static function getPivotData(
        EntityReflection $entityReflection,
        object $entity,
        PivotLinker $linker,
        Collection $linkedEntities
    ): array {
        $linkedEntityReflection = EntityReflection::new($linker->getTargetEntity());
        /** @var array<int|string,array<int|string>> $data */
        $data = $linkedEntities->map(function ($linkedEntity) use (
            $entity,
            $linker,
            $linkedEntityReflection
        ) {
            if ($linkedEntity::class !== $linkedEntityReflection->getClass()) {
                throw new InconsistentEntitiesException();
            }
            self::checkIdIsSet($linkedEntity, 'Must set ID columns of all entities when attaching/detaching');
            return [
                $linker->getOriginForeignKey() => EntityAccessorService::getId($entity),
                $linker->getTargetForeignKey() => EntityAccessorService::getId($linkedEntity),
            ];
        })->toArray();
        return $data;
    }

    private function serializeEntity(object $entity, bool $withIdColumn): array
    {
        $data = [];

        foreach ($this->entityReflection->getMappers() as $property => $mapper) {
            if (!$withIdColumn && $this->hasAutogeneratedId && $property === $this->entityReflection->getIdProperty()) {
                continue;
            }
            if (!$this->entityReflection->allowsNull($property) && !EntityAccessorService::isset($entity, $property)) {
                throw new MissingValueForColumnException($property);
            }
            $data[] = $mapper->serialize(EntityAccessorService::get($entity, $property));
        }

        $data[] = $this->resolveOwningRelations($entity);
        return array_merge(...$data);
    }

    private function persistInserts(): void
    {
        if (count($this->insertValues) > 0) {
            if ($this->hasAutogeneratedId) {
                $query = DB::table($this->entityReflection->getTableName());
                $sql = $query->grammar->compileInsert($query, $this->insertValues) . ' RETURNING ' . $this->entityReflection->getIdColumn();
                $ids = array_map(
                    fn(stdClass $item) => $item->{$this->entityReflection->getIdColumn()},
                    $query->connection->select($sql, $query->cleanBindings(Arr::flatten($this->insertValues, 1)))
                );
                foreach ($ids as $index => $id) {
                    EntityAccessorService::setId($this->insertEntities[$index], $id);
                }
            } else {
                DB::table($this->entityReflection->getTableName())->insert($this->insertValues);
            }
        }
    }

    private function persistUpdates(): void
    {
        if (count($this->updateEntities) > 0) {
            $columns = collect(array_keys($this->updateValues[0]));
            // TODO: cache column types & flush cache when migration occurs
            $columnTypes = DB::table('information_schema.columns')
                ->select(['column_name', 'data_type'])
                ->where('table_name', $this->entityReflection->getTableName())
                ->orderBy('ordinal_position')
                ->get()
                ->pluck('data_type', 'column_name');
            $placeholders = [];
            $placeholders[] = $columns->implode(fn($column) => '?::' . $columnTypes[$column], ', ');
            $placeholderRow = $columns->implode(fn($column) => '?', ', ');
            array_push($placeholders, ...Collection::times(count($this->updateValues) - 1, fn() => $placeholderRow));
            $sql = 'UPDATE '
                . $this->entityReflection->getTableName()
                . ' SET '
                . $columns->implode(fn($column) => $column . ' = ' . 'tmp2.' . $column, ', ')
                . ' FROM (VALUES ('
                . implode('), (', $placeholders)
                . ')) AS tmp2 ('
                . $columns->implode(', ')
                . ') WHERE '
                . $this->entityReflection->getTableName() . '.' . $this->entityReflection->getIdColumn()
                . ' = tmp2.' . $this->entityReflection->getIdColumn();
            $updatedRowsCount =  DB::update($sql, Arr::flatten($this->updateValues, 1));
            if ($updatedRowsCount !== count($this->updateEntities)) {
                $this->errors[] = sprintf(
                    'Could not update all entities. Updated %s out of %s.',
                    $updatedRowsCount,
                    count($this->updateEntities)
                );
            }
        }
    }

    private function persistDeletes(): void
    {
        $deletedRowsCount = DB::table($this->entityReflection->getTableName())
            ->whereIn($this->entityReflection->getIdColumn(), $this->deleteIds)
            ->delete();
        if ($deletedRowsCount !== count($this->deleteEntities)) {
            $this->errors[] = sprintf(
                'Could not delete all entities. Deleted %s out of %s.',
                $deletedRowsCount,
                count($this->deleteEntities)
            );
        }
    }

    private function checkType(object $entity): void
    {
        if (get_class($entity) !== $this->getEntityClassName()) {
            throw new PersistenceException(sprintf(
                'Tried to use entity of type %s in persistence manager configured for entities of type %s.',
                get_class($entity),
                $this->getEntityClassName()
            ));
        }
    }
}

//' [ASCII](length: 847) contains "Cannot restore entity without soft-deletes" [ASCII](length: 42).
